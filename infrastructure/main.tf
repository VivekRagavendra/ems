# Terraform/OpenTofu configuration is generated by Terragrunt
# See terragrunt.hcl for provider configuration

# Variables - values come from Terragrunt inputs

# Variables - values come from Terragrunt
variable "aws_region" {
  description = "AWS region"
  type        = string
}

variable "eks_cluster_name" {
  description = "Name of the EKS cluster"
  type        = string
}

variable "project_name" {
  description = "Project name for resource naming"
  type        = string
}

variable "lambda_runtime" {
  description = "Python runtime version for Lambda"
  type        = string
  default     = "python3.11"
}

variable "config_name" {
  description = "Config file name to use (e.g., config.yaml, config.prod.yaml, config.uat.yaml)"
  type        = string
  default     = "config.yaml"
}

variable "aws_account_id" {
  description = "AWS account ID (used for resource naming to avoid conflicts)"
  type        = string
  default     = ""
}

# DynamoDB Table for App Registry and Resource Locks
# Uses single table design: app_name for apps, LOCK#DB#<id> for locks
resource "aws_dynamodb_table" "app_registry" {
  name         = "${var.project_name}-registry"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "app_name"

  attribute {
    name = "app_name"
    type = "S"
  }

  # Enable TTL for automatic lock expiration
  ttl {
    attribute_name = "ttl"
    enabled        = true
  }

  tags = {
    Name        = "${var.project_name}-registry"
    Environment = "production"
  }
}

# DynamoDB Table for Application Costs
resource "aws_dynamodb_table" "app_costs" {
  name         = "${var.project_name}-app-costs"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "PK"  # app name
  range_key    = "SK"   # date YYYY-MM-DD

  attribute {
    name = "PK"
    type = "S"
  }

  attribute {
    name = "SK"
    type = "S"
  }

  tags = {
    Name        = "${var.project_name}-app-costs"
    Environment = "production"
  }
}

# DynamoDB Table for Application Schedules
resource "aws_dynamodb_table" "app_schedules" {
  name         = "${var.project_name}-app-schedules"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "app"

  attribute {
    name = "app"
    type = "S"
  }

  tags = {
    Name        = "${var.project_name}-app-schedules"
    Environment = "production"
  }
}

# DynamoDB Table for Operation Logs
resource "aws_dynamodb_table" "operation_logs" {
  name         = "${var.project_name}-operation-logs"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "PK"  # timestamp or operation_id
  range_key    = "SK"   # app or sort key

  attribute {
    name = "PK"
    type = "S"
  }

  attribute {
    name = "SK"
    type = "S"
  }

  # Enable TTL for automatic log expiration (90 days)
  ttl {
    attribute_name = "ttl"
    enabled        = true
  }

  tags = {
    Name        = "${var.project_name}-operation-logs"
    Environment = "production"
  }
}

# IAM Role for Discovery Lambda
resource "aws_iam_role" "discovery_lambda_role" {
  name = "${var.project_name}-discovery-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "discovery_lambda_policy" {
  name = "${var.project_name}-discovery-lambda-policy"
  role = aws_iam_role.discovery_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:PutItem",
          "dynamodb:GetItem",
          "dynamodb:UpdateItem",
          "dynamodb:Scan"
        ]
        Resource = aws_dynamodb_table.app_registry.arn
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeCluster",
          "eks:ListNodegroups",
          "eks:DescribeNodegroup"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:DescribeInstances",
          "ec2:DescribeTags"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:CreateNetworkInterface",
          "ec2:DescribeNetworkInterfaces",
          "ec2:DeleteNetworkInterface",
          "ec2:AssignPrivateIpAddresses",
          "ec2:UnassignPrivateIpAddresses"
        ]
        Resource = "*"
      }
    ]
  })
}

# IAM Role for Controller Lambda
resource "aws_iam_role" "controller_lambda_role" {
  name = "${var.project_name}-controller-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "controller_lambda_policy" {
  name = "${var.project_name}-controller-lambda-policy"
  role = aws_iam_role.controller_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:UpdateItem",
          "dynamodb:PutItem",
          "dynamodb:DeleteItem",
          "dynamodb:Scan"
        ]
        Resource = aws_dynamodb_table.app_registry.arn
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeCluster",
          "eks:DescribeNodegroup",
          "eks:UpdateNodegroupConfig"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:StartInstances",    # Required: Start EC2 instances (databases)
          "ec2:StopInstances",     # Required: Stop EC2 instances (databases)
          "ec2:DescribeInstances"  # Required: Check instance status (running/stopped)
        ]
        Resource = "*"
        # Note: Resource is "*" because instances are discovered dynamically
        # from EC2 tags and ConfigMaps. These are the minimum permissions
        # needed for the dashboard to start/stop and check EC2 instance status.
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:CreateNetworkInterface",
          "ec2:DescribeNetworkInterfaces",
          "ec2:DeleteNetworkInterface",
          "ec2:AssignPrivateIpAddresses",
          "ec2:UnassignPrivateIpAddresses"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "lambda:InvokeFunction"  # Required: Self-invoke for async operations
        ]
        Resource = "arn:aws:lambda:*:*:function:${var.project_name}-controller"
      }
    ]
  })
}

# IAM Role for Health Monitor Lambda
resource "aws_iam_role" "health_monitor_lambda_role" {
  name = "${var.project_name}-health-monitor-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "health_monitor_lambda_policy" {
  name = "${var.project_name}-health-monitor-lambda-policy"
  role = aws_iam_role.health_monitor_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:Scan",
          "dynamodb:UpdateItem"
        ]
        Resource = aws_dynamodb_table.app_registry.arn
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeNodegroup"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:DescribeInstances"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:CreateNetworkInterface",
          "ec2:DescribeNetworkInterfaces",
          "ec2:DeleteNetworkInterface",
          "ec2:AssignPrivateIpAddresses",
          "ec2:UnassignPrivateIpAddresses"
        ]
        Resource = "*"
      }
    ]
  })
}

# IAM Role for API Handler Lambda
resource "aws_iam_role" "api_handler_lambda_role" {
  name = "${var.project_name}-api-handler-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "api_handler_lambda_policy" {
  name = "${var.project_name}-api-handler-lambda-policy"
  role = aws_iam_role.api_handler_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:Scan",
          "dynamodb:GetItem",
          "dynamodb:Query",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem"
        ]
        Resource = [
          aws_dynamodb_table.app_registry.arn,
          aws_dynamodb_table.app_costs.arn,
          aws_dynamodb_table.app_schedules.arn
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeCluster",
          "eks:DescribeNodegroup"
        ]
        Resource = "*"
        # DescribeCluster is required to load Kubernetes config for pod checks
        # DescribeNodegroup is required to fetch live scaling values
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:DescribeInstances"  # Required: Check EC2 instance state for database status
        ]
        Resource = "*"
        # Required to compute database state live from EC2 instance state
      },
      {
        Effect = "Allow"
        Action = [
          "autoscaling:DescribeAutoScalingGroups"  # Required: Get current node count from ASG
        ]
        Resource = "*"
        # Required to get actual current node count for NodeGroups
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:CreateNetworkInterface",
          "ec2:DescribeNetworkInterfaces",
          "ec2:DeleteNetworkInterface",
          "ec2:AssignPrivateIpAddresses",
          "ec2:UnassignPrivateIpAddresses"
        ]
        Resource = "*"
      }
    ]
  })
}

# IAM Role for Cost Tracker Lambda
resource "aws_iam_role" "cost_tracker_lambda_role" {
  name = "${var.project_name}-cost-tracker-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "cost_tracker_lambda_policy" {
  name = "${var.project_name}-cost-tracker-lambda-policy"
  role = aws_iam_role.cost_tracker_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:PutItem",
          "dynamodb:Scan",
          "dynamodb:GetItem",
          "dynamodb:Query"
        ]
        Resource = [
          aws_dynamodb_table.app_registry.arn,
          aws_dynamodb_table.app_costs.arn
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "ce:GetCostAndUsage",
          "ce:GetCostForecast"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:DescribeInstances",
          "ec2:DescribeVolumes"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeNodegroup"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "autoscaling:DescribeAutoScalingGroups"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "cloudwatch:GetMetricData",
          "cloudwatch:GetMetricStatistics"
        ]
        Resource = "*"
      }
    ]
  })
}

# IAM Role for Scheduler Lambda
resource "aws_iam_role" "scheduler_lambda_role" {
  name = "${var.project_name}-scheduler-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "scheduler_lambda_policy" {
  name = "${var.project_name}-scheduler-lambda-policy"
  role = aws_iam_role.scheduler_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:Scan",
          "dynamodb:PutItem"
        ]
        Resource = [
          aws_dynamodb_table.app_registry.arn,
          aws_dynamodb_table.app_schedules.arn,
          aws_dynamodb_table.operation_logs.arn
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "lambda:InvokeFunction"
        ]
        Resource = [
          "arn:aws:lambda:*:*:function:${var.project_name}-*"
        ]
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:CreateNetworkInterface",
          "ec2:DescribeNetworkInterfaces",
          "ec2:DeleteNetworkInterface",
          "ec2:AssignPrivateIpAddresses",
          "ec2:UnassignPrivateIpAddresses"
        ]
        Resource = "*"
      }
    ]
  })
}

# Lambda Functions (placeholder - actual deployment via zip files)
# Note: In production, package Lambda functions and upload via CI/CD

# EventBridge Rules
# Cost-Optimized: Adjust frequency based on your needs
# More frequent = better real-time updates but slightly higher cost (still minimal)
# Less frequent = lower cost but less real-time

resource "aws_cloudwatch_event_rule" "discovery_schedule" {
  name                = "${var.project_name}-discovery-schedule"
  description         = "Trigger discovery Lambda periodically"
  schedule_expression = "rate(2 hours)" # Runs 12x/day (cost-optimized)
  # Options: "rate(1 hour)" for more frequent, "rate(4 hours)" for less frequent
}

resource "aws_cloudwatch_event_rule" "health_check_schedule" {
  name                = "${var.project_name}-health-check-schedule"
  description         = "Trigger health monitor Lambda periodically"
  schedule_expression = "rate(1 minute)" # Runs 1440x/day for real-time status updates
  # Changed from 15 minutes to 1 minute for immediate status updates
  # Cost impact: Still minimal (~$1-2/month, well within free tier)
}

resource "aws_cloudwatch_event_rule" "cost_tracker_schedule" {
  name                = "${var.project_name}-cost-tracker-schedule"
  description         = "Trigger cost tracker Lambda daily at 00:30 UTC"
  schedule_expression = "cron(30 0 * * ? *)" # Daily at 00:30 UTC
}

resource "aws_cloudwatch_event_rule" "scheduler_schedule" {
  name                = "${var.project_name}-scheduler-schedule"
  description         = "Trigger scheduler Lambda every 5 minutes"
  schedule_expression = "rate(5 minutes)" # Runs every 5 minutes
}

# Outputs
output "dynamodb_table_name" {
  value       = aws_dynamodb_table.app_registry.name
  description = "DynamoDB table name for app registry"
}

output "discovery_lambda_role_arn" {
  value       = aws_iam_role.discovery_lambda_role.arn
  description = "IAM role ARN for discovery Lambda"
}

output "controller_lambda_role_arn" {
  value       = aws_iam_role.controller_lambda_role.arn
  description = "IAM role ARN for controller Lambda"
}

output "health_monitor_lambda_role_arn" {
  value       = aws_iam_role.health_monitor_lambda_role.arn
  description = "IAM role ARN for health monitor Lambda"
}

output "api_handler_lambda_role_arn" {
  value       = aws_iam_role.api_handler_lambda_role.arn
  description = "IAM role ARN for API handler Lambda"
}

