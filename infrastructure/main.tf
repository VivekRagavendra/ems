# Terraform/OpenTofu configuration is generated by Terragrunt
# See terragrunt.hcl for provider configuration

# Variables - values come from Terragrunt inputs

# Variables - values come from Terragrunt
variable "aws_region" {
  description = "AWS region"
  type        = string
}

variable "eks_cluster_name" {
  description = "Name of the EKS cluster"
  type        = string
}

variable "project_name" {
  description = "Project name for resource naming"
  type        = string
}

variable "lambda_runtime" {
  description = "Python runtime version for Lambda"
  type        = string
  default     = "python3.11"
}

# DynamoDB Table
resource "aws_dynamodb_table" "app_registry" {
  name         = "${var.project_name}-registry"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "app_name"

  attribute {
    name = "app_name"
    type = "S"
  }

  tags = {
    Name        = "${var.project_name}-registry"
    Environment = "production"
  }
}

# IAM Role for Discovery Lambda
resource "aws_iam_role" "discovery_lambda_role" {
  name = "${var.project_name}-discovery-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "discovery_lambda_policy" {
  name = "${var.project_name}-discovery-lambda-policy"
  role = aws_iam_role.discovery_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:PutItem",
          "dynamodb:GetItem",
          "dynamodb:UpdateItem",
          "dynamodb:Scan"
        ]
        Resource = aws_dynamodb_table.app_registry.arn
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeCluster",
          "eks:ListNodegroups",
          "eks:DescribeNodegroup"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:DescribeInstances",
          "ec2:DescribeTags"
        ]
        Resource = "*"
      }
    ]
  })
}

# IAM Role for Controller Lambda
resource "aws_iam_role" "controller_lambda_role" {
  name = "${var.project_name}-controller-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "controller_lambda_policy" {
  name = "${var.project_name}-controller-lambda-policy"
  role = aws_iam_role.controller_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:UpdateItem"
        ]
        Resource = aws_dynamodb_table.app_registry.arn
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeCluster",
          "eks:DescribeNodegroup",
          "eks:UpdateNodegroupConfig"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:StartInstances",    # Required: Start EC2 instances (databases)
          "ec2:StopInstances",     # Required: Stop EC2 instances (databases)
          "ec2:DescribeInstances"  # Required: Check instance status (running/stopped)
        ]
        Resource = "*"
        # Note: Resource is "*" because instances are discovered dynamically
        # from EC2 tags and ConfigMaps. These are the minimum permissions
        # needed for the dashboard to start/stop and check EC2 instance status.
      },
      {
        Effect = "Allow"
        Action = [
          "lambda:InvokeFunction"  # Required: Self-invoke for async operations
        ]
        Resource = "arn:aws:lambda:*:*:function:${var.project_name}-controller"
      }
    ]
  })
}

# IAM Role for Health Monitor Lambda
resource "aws_iam_role" "health_monitor_lambda_role" {
  name = "${var.project_name}-health-monitor-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "health_monitor_lambda_policy" {
  name = "${var.project_name}-health-monitor-lambda-policy"
  role = aws_iam_role.health_monitor_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:Scan",
          "dynamodb:UpdateItem"
        ]
        Resource = aws_dynamodb_table.app_registry.arn
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeNodegroup"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:DescribeInstances"
        ]
        Resource = "*"
      }
    ]
  })
}

# IAM Role for API Handler Lambda
resource "aws_iam_role" "api_handler_lambda_role" {
  name = "${var.project_name}-api-handler-lambda-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "lambda.amazonaws.com"
        }
      }
    ]
  })
}

resource "aws_iam_role_policy" "api_handler_lambda_policy" {
  name = "${var.project_name}-api-handler-lambda-policy"
  role = aws_iam_role.api_handler_lambda_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "arn:aws:logs:*:*:*"
      },
      {
        Effect = "Allow"
        Action = [
          "dynamodb:Scan",
          "dynamodb:GetItem"
        ]
        Resource = aws_dynamodb_table.app_registry.arn
      },
      {
        Effect = "Allow"
        Action = [
          "eks:DescribeCluster",
          "eks:DescribeNodegroup"
        ]
        Resource = "*"
        # DescribeCluster is required to load Kubernetes config for pod checks
        # DescribeNodegroup is required to fetch live scaling values
      },
      {
        Effect = "Allow"
        Action = [
          "ec2:DescribeInstances"  # Required: Check EC2 instance state for database status
        ]
        Resource = "*"
        # Required to compute database state live from EC2 instance state
      },
      {
        Effect = "Allow"
        Action = [
          "autoscaling:DescribeAutoScalingGroups"  # Required: Get current node count from ASG
        ]
        Resource = "*"
        # Required to get actual current node count for NodeGroups
      }
    ]
  })
}

# Lambda Functions (placeholder - actual deployment via zip files)
# Note: In production, package Lambda functions and upload via CI/CD

# EventBridge Rules
# Cost-Optimized: Adjust frequency based on your needs
# More frequent = better real-time updates but slightly higher cost (still minimal)
# Less frequent = lower cost but less real-time

resource "aws_cloudwatch_event_rule" "discovery_schedule" {
  name                = "${var.project_name}-discovery-schedule"
  description         = "Trigger discovery Lambda periodically"
  schedule_expression = "rate(2 hours)" # Runs 12x/day (cost-optimized)
  # Options: "rate(1 hour)" for more frequent, "rate(4 hours)" for less frequent
}

resource "aws_cloudwatch_event_rule" "health_check_schedule" {
  name                = "${var.project_name}-health-check-schedule"
  description         = "Trigger health monitor Lambda periodically"
  schedule_expression = "rate(1 minute)" # Runs 1440x/day for real-time status updates
  # Changed from 15 minutes to 1 minute for immediate status updates
  # Cost impact: Still minimal (~$1-2/month, well within free tier)
}

# Outputs
output "dynamodb_table_name" {
  value       = aws_dynamodb_table.app_registry.name
  description = "DynamoDB table name for app registry"
}

output "discovery_lambda_role_arn" {
  value       = aws_iam_role.discovery_lambda_role.arn
  description = "IAM role ARN for discovery Lambda"
}

output "controller_lambda_role_arn" {
  value       = aws_iam_role.controller_lambda_role.arn
  description = "IAM role ARN for controller Lambda"
}

output "health_monitor_lambda_role_arn" {
  value       = aws_iam_role.health_monitor_lambda_role.arn
  description = "IAM role ARN for health monitor Lambda"
}

output "api_handler_lambda_role_arn" {
  value       = aws_iam_role.api_handler_lambda_role.arn
  description = "IAM role ARN for API handler Lambda"
}

